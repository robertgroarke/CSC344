/*
  ==============================================================================

    This file was auto-generated by the Jucer!

    It contains the basic startup code for a Juce application.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

AudioProcessor* JUCE_CALLTYPE createPluginFilter();


//==============================================================================
/** A demo synth sound that's just a basic sine wave.. */
class WaveSound : public SynthesiserSound
{
public:
    WaveSound() {}

    bool appliesToNote (const int /*midiNoteNumber*/)           { return true; }
    bool appliesToChannel (const int /*midiChannel*/)           { return true; }
};


//==============================================================================
/** A Wavetable **/

// NB: ANGLES SPECIFIED IN ROTATIONS, NOT RADIANS.

#define WAVETABLE_SIZE 1000
// this is one larger than needed, to prevent
// having to special-case the wraparound.
#define WAVETABLE_ARRAY_SIZE (WAVETABLE_SIZE + 1)
class WaveTable
{
public:
	float table[WAVETABLE_ARRAY_SIZE];

	// given a number in 0<angle<1.0, return 
	// a (linearly interpolated) number from the wavetable.
	float lookup(double angle){
		// yes, we could avoid all of the multiplication if we 
		// pushed the wavetable size into the angle....
		const double scaled_angle = angle * WAVETABLE_SIZE;
		const double lower = floor(scaled_angle);
		const double fraction = scaled_angle - lower;
		return (table[(int)lower] * (1.0 - fraction))
			+ (table[(int)lower + 1] * fraction);
	}

	void squareInit(){
		for (int i = 0; i < WAVETABLE_SIZE; i++){
			table[i] = ((i < (WAVETABLE_SIZE / 2)) ? 1.0 : -1.0);
		}
		table[WAVETABLE_SIZE] = 1.0;
	}

	void sineInit(){
		for (int i = 0; i < WAVETABLE_SIZE; i++){
			table[i] = sin(2.0 * double_Pi * ((double)i / WAVETABLE_SIZE));
		}
		table[WAVETABLE_SIZE] = 0.0;
	}

	void triangleInit(){
		for (int i = 0; i < WAVETABLE_SIZE / 2; i++){
			table[i] = (((double)i * 2) / WAVETABLE_SIZE);
		}
		for (int i = WAVETABLE_SIZE / 2; i < WAVETABLE_SIZE; i++){
			table[i] = 1 - ( ( ((double)i - WAVETABLE_SIZE / 2) * 2)/ WAVETABLE_SIZE);
		}
		table[WAVETABLE_SIZE] = 0.0;
	}

	void sawtoothInit(){
		for (int i = 0; i < WAVETABLE_SIZE; i++){
			table[i] = ((double)i / WAVETABLE_SIZE);
		}
		table[WAVETABLE_SIZE] = 0.0;
	}

	void doublingtriangleInit(){
		int mult = ( rand() > (RAND_MAX / 2) ) + 1;

		for (int i = 0; i < WAVETABLE_SIZE / 2; i++){
			table[i] = mult * (((double)i * 2) / WAVETABLE_SIZE);
		}
		for (int i = WAVETABLE_SIZE / 2; i < WAVETABLE_SIZE; i++){
			table[i] = mult * (1 - ((((double)i - WAVETABLE_SIZE / 2) * 2) / WAVETABLE_SIZE));
		}
		table[WAVETABLE_SIZE] = 0.0;
	}
};

#define HARMONICS 4

//==============================================================================
/** A simple demo synth voice that just plays a sine wave.. */
class WaveVoice  : public SynthesiserVoice
{
public:
    WaveVoice()
    : playing(notPlaying),
	angleDelta (0.0),
    tailOff (0.0),
	wavetable()
	{
		wavetable.sawtoothInit();
	}

    bool canPlaySound (SynthesiserSound* sound)
    {
        return dynamic_cast <WaveSound*> (sound) != 0;
    }

    void startNote (int midiNoteNumber, float velocity,
                    SynthesiserSound* /*sound*/, int /*currentPitchWheelPosition*/)
    {
		playing = keyHeld;
        currentAngle = 0.0;

		for (int i = 0; i < HARMONICS; i++) {
			levels[i] = 0.25;
		}

        level = velocity * 0.15;
		//tailOff = 0.0;

        double cyclesPerSecond = MidiMessage::getMidiNoteInHertz (midiNoteNumber);
        double cyclesPerSample = cyclesPerSecond / getSampleRate();

		angleDelta = cyclesPerSample;

		//reset o1
		o1_angle = 0.0;
		o1_angleDelta = o1_freq / getSampleRate();

        //angleDelta = cyclesPerSample * 2.0 * double_Pi;
    }

	void stopNote(bool allowTailOff)
	{
		if (allowTailOff)
		{
			// start a tail-off by setting this flag. The render callback will pick up on
			// this and do a fade out, calling clearCurrentNote() when it's finished.
			if (playing == keyHeld) {
				// we only need to begin a tail-off if it's not already doing so - the
				// stopNote method could be called more than once.
				playing = keyReleased;
				tailOff = 1.0;
			}
		}
		else
		{
			// we're being told to stop playing immediately, so reset everything..
			clearCurrentNote();
			playing = notPlaying;
			angleDelta = 0.0;
		}
	}

    void pitchWheelMoved (int /*newValue*/)
    {
        // can't be bothered implementing this for the demo!
    }

    void controllerMoved (int /*controllerNumber*/, int /*newValue*/)
    {
        // not interested in controllers in this case.
    }

	void renderNextBlock(AudioSampleBuffer& outputBuffer, int startSample, int numSamples)
	{
		if (playing != notPlaying) {
			const double levelMult = level * (playing == keyReleased ? tailOff : 1.0);
			for (int sample = startSample; sample < startSample + numSamples; sample++){
				const double o1 = (sin(o1_angle * 2.0 * double_Pi));
				const double amplitude = 1.0 + (0.5 * o1);
				const float currentSampleVal =
					(float)(wavetable.lookup(currentAngle) * levelMult * amplitude);

				for (int i = outputBuffer.getNumChannels(); --i >= 0;) {
					*outputBuffer.getSampleData(i, sample) += currentSampleVal;
				}

				currentAngle = angleWrap(currentAngle + angleDelta);
				o1_angle = angleWrap(o1_angle + o1_angleDelta);

				if (playing == keyReleased) {
					tailOff *= 0.99;

					if (tailOff <= 0.005)
					{
						clearCurrentNote();
						playing = notPlaying;
						angleDelta = 0.0;
						break;
					}
				}
			}
		}
	}

private:
	// wrap an angle around. ASSUMES IT'S NOT GREATER THAN 2.
	double angleWrap(double angle) const {
		return (angle > 1.0 ? angle - 1.0 : angle);
	}

	enum PlayState
	{
		notPlaying = 0,
		keyHeld,
		keyReleased
	};


	PlayState playing;
	double angles[HARMONICS];
	double levels[HARMONICS];
	// all angles are measured in *rotations*, not radians.
	double currentAngle, angleDelta;
	double level, tailOff;
	// osc1
	double o1_freq = 12;
	double o1_angle, o1_angleDelta;
	// a wavetable
	WaveTable wavetable;
};

//==============================================================================
JuceDemoPluginAudioProcessor::JuceDemoPluginAudioProcessor()
{

    lastUIWidth = 400;
    lastUIHeight = 200;

    lastPosInfo.resetToDefault();

    // Initialise the synth...
    for (int i = 4; --i >= 0;)
        synth.addVoice (new WaveVoice());   // These voices will play our custom sine-wave sounds..

    synth.addSound (new WaveSound());
}

JuceDemoPluginAudioProcessor::~JuceDemoPluginAudioProcessor()
{
}

//==============================================================================
int JuceDemoPluginAudioProcessor::getNumParameters()
{
    return 0;
}

float JuceDemoPluginAudioProcessor::getParameter (int index)
{
	return 0.0f;
}

void JuceDemoPluginAudioProcessor::setParameter (int index, float newValue)
{
}

float JuceDemoPluginAudioProcessor::getParameterDefaultValue (int index)
{
    return 0.0f;
}

const String JuceDemoPluginAudioProcessor::getParameterName (int index)
{
	return String::empty;
}

const String JuceDemoPluginAudioProcessor::getParameterText (int index)
{
	return String::empty;
}

//==============================================================================
void JuceDemoPluginAudioProcessor::prepareToPlay (double sampleRate, int /*samplesPerBlock*/)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
    synth.setCurrentPlaybackSampleRate (sampleRate);
    keyboardState.reset();
    //delayBuffer.clear();
}

void JuceDemoPluginAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
    keyboardState.reset();
}

void JuceDemoPluginAudioProcessor::processBlock(AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
	const int numSamples = buffer.getNumSamples();

	// output buffers will initially be garbage, must be cleared:
	for (int i = 0; i < getNumOutputChannels(); ++i) {
		buffer.clear(i, 0, numSamples);
	}

	// Now pass any incoming midi messages to our keyboard state object, and let it
	// add messages to the buffer if the user is clicking on the on-screen keys
	keyboardState.processNextMidiBuffer(midiMessages, 0, numSamples, true);

	// and now get the synth to process these midi events and generate its output.
	synth.renderNextBlock(buffer, midiMessages, 0, numSamples);

	// ask the host for the current time so we can display it...
	AudioPlayHead::CurrentPositionInfo newTime;

	if (getPlayHead() != nullptr && getPlayHead()->getCurrentPosition(newTime))
	{
		// Successfully got the current time from the host..
		lastPosInfo = newTime;
	}
	else
	{
		// If the host fails to fill-in the current time, we'll just clear it to a default..
		lastPosInfo.resetToDefault();
	}

}

//==============================================================================
AudioProcessorEditor* JuceDemoPluginAudioProcessor::createEditor()
{
    return new JuceDemoPluginAudioProcessorEditor (this);
}

//==============================================================================
void JuceDemoPluginAudioProcessor::getStateInformation (MemoryBlock& destData)
{
}

void JuceDemoPluginAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
}

const String JuceDemoPluginAudioProcessor::getInputChannelName (const int channelIndex) const
{
    return String (channelIndex + 1);
}

const String JuceDemoPluginAudioProcessor::getOutputChannelName (const int channelIndex) const
{
    return String (channelIndex + 1);
}

bool JuceDemoPluginAudioProcessor::isInputChannelStereoPair (int /*index*/) const
{
    return true;
}

bool JuceDemoPluginAudioProcessor::isOutputChannelStereoPair (int /*index*/) const
{
    return true;
}

bool JuceDemoPluginAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool JuceDemoPluginAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool JuceDemoPluginAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double JuceDemoPluginAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new JuceDemoPluginAudioProcessor();
}
